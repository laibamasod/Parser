how to run:
flex lexer.l
gcc lex.yy.c
./a.out input_file.txt
yacc -d parser.y  # Generate the parser code
gcc y.tab.c -o parser_executable  # Compile the parser code
./parser_executable input_file.txt  # Run the parser on the input file


Uppercase symbols typically represent non-terminal symbols.
Lowercase symbols or strings represent terminal symbols.


lexer.l is lexical analysis or tokenization phase. 
It breaks the input stream into tokens based on patterns defined using regular expressions.

parser.y defines the grammar rules and syntax analysis phase.
 It specifies how tokens identified by the le
 xer are structured according to the language's grammar.

Parsing Algorithm used by Parser: Bottom Up Parser
to build a parse tree from the input text  ( Shift Reduce)   (LR or GLR)
from input text -> all the way up to start symbol

Σ has the whole language ( terminal + non terminals )
Σ = { PROGRAM, FUNCTION, PARAMLIST, PARAMREST, BLOCK, STATEMENT, BREAK, CALL,
ARGLIST, ARGREST, IF, ELSE, LET, READ, RETURN, WHILE, WRITE, EXPR, BINOP, UNOP, number,
identifer, function, break, call, if, else, let, read, return, while, write, (, ), {, },  ;, =, +, -, *, /, %, <, >, <=, >=,
==, !=, &, |, ~, !}


terminal Symbols (V):

number, identifier, function, break, call, if, else, let, read, return, while, write, (, ), {, }, ;, =, +, -, *, /, %, <, >, <=, >=, ==, !=, &, |, ~, !


 start symbol S = PROGRAM

1. **PROGRAM → FUNCTION* BLOCK**
   - Describes the structure of a program in SL.
   - It consists of zero or more functions followed by a block of statements.

2. **FUNCTION → function identifier ( PARAMLIST ) BLOCK**
   - Defines the structure of a function in SL.
   - It starts with the keyword `function`, followed by an identifier (function name), a parameter list enclosed in parentheses, and a block of statements.

3. **PARAMLIST → identifier PARAMREST | ε**
   - Represents the list of parameters in a function.
   - It can begin with an identifier (parameter) followed by a parameter rest or be empty (epsilon).

4. **PARAMREST → , identifier PARAMREST | ε**
   - Extends the parameter list.
   - It allows multiple identifiers separated by commas or can be empty.

5. **BLOCK → { STATEMENT* }**
   - Defines a block of statements enclosed in curly braces.
   - It can contain zero or more statements.

6. **STATEMENT → BREAK | CALL ; | IF | LET | READ | RETURN | WHILE | WRITE**
   - Specifies various types of statements in SL, such as Break, Call, If, Let, Read, Return, While, Write.

7. **BREAK → break ;**
   - Represents the `break` statement followed by a semicolon.

8. **CALL → call identifier ( ARGLIST )**
   - Describes a function call statement with the `call` keyword, an identifier (function name), and an argument list enclosed in parentheses.

9. **ARGLIST → EXPR ARGREST | ε**
   - Represents the argument list for a function call.
   - It can begin with an expression followed by an argument rest or be empty.

10. **ARGREST → , EXPR ARGREST | ε**
    - Extends the argument list.
    - It allows multiple expressions separated by commas or can be empty.

11. **IF → if EXPR BLOCK ELSE**
    - Represents an `if` statement with an expression, a block of statements for the true condition, and an optional else block.

12. **ELSE → else BLOCK | ε**
    - Specifies an optional `else` block containing statements or can be empty.

13. **LET → let identifier = EXPR ; | let identifier = CALL ;**
    - Defines variable assignment using the `let` keyword followed by an identifier and either an expression or a function call.

14. **READ → read identifier ;**
    - Represents a `read` statement where a value is read into an identifier.

15. **RETURN → return EXPR ;**
    - Describes a `return` statement followed by an expression and ending with a semicolon.

16. **WHILE → while EXPR BLOCK**
    - Specifies a `while` loop with an expression and a block of statements.

17. **WRITE → write EXPR ;**
    - Represents a `write` statement with an expression to be output and ending with a semicolon.

18. **EXPR → number | identifier | ( EXPR ) | ( UNOP EXPR ) | ( BINOP EXPR EXPR )**
    - Defines expressions in SL: a number, an identifier, a parenthesized expression, a unary operation with an expression, or a binary operation with two expressions.

19. **BINOP → + | - | * | / | % | & | | | < | > | <= | >= | == | !=**
    - Represents binary operations such as addition, subtraction, etc.

20. **UNOP → ~ | !**
    - Specifies unary operations like bitwise negation and logical negation.


Lexical Analyzer File (.l):

This file contains the definitions of tokens, patterns, and rules for the lexical analyzer generated by Flex.
Example filename: lexer.l


An input file describes the lexical analyzer to be generated named lex.l is written in lex language. The lex compiler transforms lex.l to 
C program, in a file that is always named lex.yy.c. 
Step 2: The C compiler compile lex.yy.c file into an executable file called a.out. 
Step 3: The output file a.out take a stream of input characters and produce a stream of tokens.

yywrap is a function that handles end-of-file conditions. 
Flex's default behavior is to return 1 from yywrap, indicating that there is no more input. 
This signals the parser (usually generated by Bison) that it should stop requesting more tokens from the lexer.
